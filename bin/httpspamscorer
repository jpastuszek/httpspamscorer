#!/usr/bin/env ruby
require 'unicorn-cuba-base'
require 'excon'

$LOAD_PATH.unshift(File.join(File.dirname(__FILE__), '..', 'lib'))

require 'httpspamscorer/reconstructed_mail'

Application.new('httpspamscorer', port: 4000) do
	cli do
		description 'Spam Soring HTTP server'
		version (Pathname.new(__FILE__).dirname + '..' + 'VERSION').read
	end

	settings do |settings|
	end

	main do |settings|
		class HTTPSpamScorer < Controller
			extend Stats
			def_stats(
				:workers,
				:total_requests,
				:total_errors
			)

			raindrops_stats = Raindrops::Middleware::Stats.new
			self.use Raindrops::Middleware, stats: raindrops_stats

			StatsReporter << HTTPSpamScorer.stats
			StatsReporter << raindrops_stats
			#StatsReporter << Plugin::Thumbnailer::Service.stats
			StatsReporter << Plugin::ResponseHelpers.stats

			normal = Excon.new('http://dev.jp-spam:11333', read_timeout: 4) #, :persistent => true)

			self.define do
				HTTPSpamScorer.stats.incr_total_requests
				on error? do
					HTTPSpamScorer.stats.incr_total_errors
					run DefaultErrorReporter
				end

				on 'stats' do
					run StatsReporter
				end

				on 'health_check' do
					write_plain 200, 'HTTP Spam Scorer OK'
				end

				on root do
					write_plain 200, 'HTTP Spam Scorer'
				end

				on 'check' do
					msg = JSON.parse(req.body.read.to_s)

					mail = ReconstructedMail.from_hash(msg)

					headers = {}

					received = msg['received'] || mail.header['Received'].map(&:value).select{|val| val =~ /^from /}.first
					received_for = mail.header['Received'].map(&:value).select{|val| val =~ / for </}.first

					# first try to parse Received that contains for e-mail address so we can verify Rcpt
					begin
						helo, ip, hostname, to = * received_for.match(/from (?:\[[^ ]+\]|([^\[][^ ]+)) \((?:[^ ]+ )?\[([^\]]+)\]\)(?: by ([^ ]+))?(?:.* for <([^>]+)>)?/).captures

						headers['Hostname'] = hostname if hostname
						headers['Helo'] = helo if helo
						headers['Ip'] = ip if ip
						headers['Rcpt'] = to if to
					rescue
						log.warn "can't parse received_for string: #{received_for}"
					end if received_for

					# parse first Received header that should contain information of the actual sender SMTP server
					begin
						helo, ip, hostname, to = * received.match(/from (?:\[[^ ]+\]|([^\[][^ ]+)) \((?:[^ ]+ )?\[([^\]]+)\]\)(?: by ([^ ]+))?(?:.* for <([^>]+)>)?/).captures

						headers['Hostname'] = hostname if hostname
						headers['Helo'] = helo if helo
						headers['Ip'] = ip if ip
						headers['Rcpt'] = to if to
					rescue
						log.warn "can't parse received string: #{received}"
					end if received

					p headers

					headers['Hostname'] = msg['hostname'] if msg['hostname']
					headers['User'] = msg['user'] if msg['user']
					headers['Deliver-To'] = msg['deliver-to'] if msg['deliver-to']
					headers['Helo'] = msg['helo'] if msg['helo']
					headers['Ip'] = msg['ip'] if msg['ip']
					headers['From'] = msg['from'] if msg['from']
					headers['Rcpt'] = msg['rcpt'] if msg['rcpt']

					resp = normal.post path: '/check', headers: headers, body: mail.to_s

					write_plain 200, resp.body
				end
			end
		end

		HTTPSpamScorer
	end

	after_fork do |server, worker|
		HTTPSpamScorer.stats.incr_workers
	end
end
